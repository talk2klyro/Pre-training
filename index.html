<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Virtual Host</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

// Load avatar metadata
let avatarData;
fetch('avatar.json')
  .then(response => response.json())
  .then(data => { avatarData = data; init(); });

let scene, camera, renderer, controls, character, mixer, raycaster, mouse;
const idleAnimations = [];

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);

    const light = new THREE.HemisphereLight(0xffffff,0x444444,1);
    scene.add(light);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    const loader = new GLTFLoader();
    loader.load('Interactive_Virtual_Host_Male_Character.glb', function(gltf){
        character = gltf.scene;
        scene.add(character);
        mixer = new THREE.AnimationMixer(character);

        // Play all idle animations automatically
        gltf.animations.forEach(clip => {
            const action = mixer.clipAction(clip);
            if (clip.name.startsWith('idle')) {
                action.play();
                idleAnimations.push(action);
            }
        });

        // Keep other animations ready for triggers
        gltf.animations.forEach(clip => {
            if (!clip.name.startsWith('idle')) {
                mixer.clipAction(clip); // prepare action, will trigger later
            }
        });
    });

    camera.position.set(0, avatarData.orientation_scale.height, 3);

    // Event Listeners
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('click', onClick);
    window.addEventListener('keydown', onKeyDown);

    animate();
}

// Mouse hover animation
function onMouseMove(event) {
    if (!character) return;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(character, true);
    if (intersects.length > 0) {
        mixer.clipAction('wave_right_hand')?.reset().play();
    }
}

// Mouse click animation
function onClick(event) {
    if (!character) return;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(character, true);
    if (intersects.length > 0) {
        mixer.clipAction('smile_friendly')?.reset().play();
    }
}

// Keyboard shortcuts
function onKeyDown(event) {
    if (!mixer) return;
    switch(event.key){
        case 'T': mixer.clipAction('thumbs_up')?.reset().play(); break;
        case 'N': mixer.clipAction('nod_head')?.reset().play(); break;
        case 'S': mixer.clipAction('surprised_face')?.reset().play(); break;
        case 'W': mixer.clipAction('wink_left_eye')?.reset().play(); break;
    }
}

function animate() {
    requestAnimationFrame(animate);
    if (mixer) mixer.update(0.016);
    renderer.render(scene, camera);
}
</script>

</body>
  </html>
